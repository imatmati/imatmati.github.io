<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/public/stylesheets/bs.css">
    <link rel="stylesheet" href="/public/stylesheets/enhance/zoom.css">
    <link rel="stylesheet" href="/public/stylesheets/enhance/classes.css">
    <link rel="stylesheet" href="/public/stylesheets/styles.css">
    <link rel="stylesheet" href="/public/stylesheets/pygment_trac.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css">
    <link rel="canonical" href="http://localhost:4000/posts/golang-reflection">
    <link rel="stylesheet" href="/public/stylesheets/syntax.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
      <link rel="icon" type="image/x-icon"  href="/favicon.ico" />
    <title>Reflection with Golang | imatmati-blog</title>
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  </head>
  <body>
    <div class="wrapper">
        <section>
          <div id="title">
  <h1>
    
		  <a id="git-ic" href="https://github.com/imatmati"><i class="fa fa-github"></i></a>	
    

    
      <a id="so-ic" href="https://fr.linkedin.com/in/ivan-matmati-0a0277b0"><i class="fa fa-linkedin"></i></a>
    

		
    <a id="sitename" href="">imatmati.github.io</a>
  </h1>

  <!-- Add something about you in p tag-->
  <p>Because technics matters ...</p>
  <hr/>
  
  <span class="credits left">
  <a href="/blog">Blog</a> |
  <a href="/archive">Archive</a> |
  <a href="/about">About</a>
</span>

<span class="credits right">

</span>
 
	 
</div>




          <div class="post-title">
    <h1>Reflection with Golang</h1>
    <p class="text-muted">13 Mar 2019 | <i class="fa fa-tag"></i>
  
  
  <a class="text-muted" href="/tags/#Golang">Golang</a>,
  
  <a class="text-muted" href="/tags/#Reflection">Reflection</a>,
  
  <a class="text-muted" href="/tags/#Programming">Programming</a>
  


</p>

</div>

  <p>From Wikipedia : “In computer science, reflection is the ability of a computer program to examine, introspect, and modify its own structure and behavior at runtime.”
Golang has a reflection package named reflect but you can hardly find examples of its use whether in tutorials or even in large projects.</p>

<p>For instance, Kubernetes code mainly uses the deep equality ability from this package and a few type information gathering. But what about modifying structure and behavior ?</p>

<p>There’s a case where this could be very handy. Have you ever been in the situation where you’re coding a software that resorts heavily on channels ?
Actually, if you’re fully using Go, this should happen often. But what if many of the functions you’re calling are just returning plain old types aka non channel types ?
Transforming the original function to adapt it to you need is clearly a use case of reflection. How to do it with Go reflection ?
See below the code and comments to explain the different attempts to achieve that in the most natural way i.e. without reflection code.</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="c">// main</span><span class="x">
</span><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="p">(</span><span class="x">
	</span><span class="s">"fmt"</span><span class="x">
	</span><span class="s">"reflect"</span><span class="x">
</span><span class="p">)</span><span class="x">

</span><span class="c">// boring function for the sake of test.</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="n">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="x"> </span><span class="n">b</span><span class="p">,</span><span class="x"> </span><span class="n">q</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="n">b</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="n">q</span><span class="p">,</span><span class="x"> </span><span class="n">a</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="n">b</span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="x"> </span><span class="no">nil</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="c">/*
make_function receives a function as argument and returns an other function as a Value.
This new function encapsulates the original one and returns channel for every original returned value.
*/</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="n">make_function</span><span class="p">(</span><span class="n">f</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">v</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="x">
	</span><span class="n">t</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">TypeOf</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="x">

</span><span class="c">/* 
fn is the function that is used to encapsulate the original function
The signature of this function is imposed by the MakeFunc call below. 
reflect.Value slices used as arguments and returned values types make fn suitable to replace any function.
*/</span><span class="x">

	</span><span class="n">fn</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">args</span><span class="x"> </span><span class="p">[]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span><span class="x"> </span><span class="p">[]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="c">// results contains every channel ...</span><span class="x">
		</span><span class="n">results</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">NumOut</span><span class="p">())</span><span class="x">
		</span><span class="c">// ... corresponding to each returned value type.</span><span class="x">
		</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">NumOut</span><span class="p">();</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
</span><span class="c">/* 
	Every channel is built by reflection. ChanOf creates the type of the channel from the type of the corresponding returned value. MakeChan builds the channel from the specification returned by ChanOf. Pay attention that MakeChan can only accept channel that sends and receives (BothDir).
*/</span><span class="x">
			</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">MakeChan</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">ChanOf</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">BothDir</span><span class="p">,</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">Out</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span><span class="x"> </span><span class="m">0</span><span class="p">)</span><span class="x">
		</span><span class="p">}</span><span class="x">
		</span><span class="c">// The original function is called.</span><span class="x">
		</span><span class="n">values</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">v</span><span class="o">.</span><span class="n">Call</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="x">
		</span><span class="c">// The returned values are now dispatched to ...</span><span class="x">
		</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">value</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">values</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="c">// ... corresponding channels</span><span class="x">
			</span><span class="c">// The sending is done through goroutines to prevent deadlock.</span><span class="x">
			</span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">k</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">val</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
				</span><span class="n">results</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">Send</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="x">
			</span><span class="p">}(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">value</span><span class="p">)</span><span class="x">
		</span><span class="p">}</span><span class="x">

		</span><span class="k">return</span><span class="x"> </span><span class="n">results</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="c">// ins ans outs are slices of types respectively of arguments and returned values.</span><span class="x">
	</span><span class="n">ins</span><span class="p">,</span><span class="x"> </span><span class="n">outs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Type</span><span class="p">,</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">NumIn</span><span class="p">()),</span><span class="x"> </span><span class="nb">make</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Type</span><span class="p">,</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">NumOut</span><span class="p">())</span><span class="x">
	</span><span class="c">// ins conserves the original types of arguments ...</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">NumIn</span><span class="p">();</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">ins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">In</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="c">// ... but outs replaces every returned value by its channel counterpart.</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">NumOut</span><span class="p">();</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">outs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">ChanOf</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">BothDir</span><span class="p">,</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">Out</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="c">// reflect.FuncOf defines the type of the new function.</span><span class="x">
	</span><span class="c">// Then reflect.MakeFunc implements dynamically the new function from the definition</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">MakeFunc</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">FuncOf</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span><span class="x"> </span><span class="n">outs</span><span class="p">,</span><span class="x"> </span><span class="no">false</span><span class="p">),</span><span class="x"> </span><span class="n">fn</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">

	</span><span class="c">// I get the new function from the original one.</span><span class="x">
	</span><span class="n">newF</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">make_function</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="x">
	</span><span class="c">// As a the new function is a Value, it's called through the reflection API.</span><span class="x">
	</span><span class="n">values</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">newF</span><span class="o">.</span><span class="n">Call</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">{</span><span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="m">10</span><span class="p">),</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="m">34</span><span class="p">),</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="m">5</span><span class="p">)})</span><span class="x">
	</span><span class="c">/* 
The channels are returned as slice of Value, so you can't use them directly in a select statement.You must resort to reflection API to build dynamically the select case to get the returned values.First, you create the select cases, not as statements but as objects.
	*/</span><span class="x">
	</span><span class="n">prod</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">SelectCase</span><span class="p">{</span><span class="n">Dir</span><span class="o">:</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">SelectRecv</span><span class="p">,</span><span class="x"> </span><span class="n">Chan</span><span class="o">:</span><span class="x"> </span><span class="n">values</span><span class="p">[</span><span class="m">0</span><span class="p">]}</span><span class="x">
	</span><span class="n">prodsum</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">SelectCase</span><span class="p">{</span><span class="n">Dir</span><span class="o">:</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">SelectRecv</span><span class="p">,</span><span class="x"> </span><span class="n">Chan</span><span class="o">:</span><span class="x"> </span><span class="n">values</span><span class="p">[</span><span class="m">1</span><span class="p">]}</span><span class="x">
	</span><span class="n">errSel</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">SelectCase</span><span class="p">{</span><span class="n">Dir</span><span class="o">:</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">SelectRecv</span><span class="p">,</span><span class="x"> </span><span class="n">Chan</span><span class="o">:</span><span class="x"> </span><span class="n">values</span><span class="p">[</span><span class="m">2</span><span class="p">]}</span><span class="x">
	</span><span class="k">var</span><span class="x"> </span><span class="p">(</span><span class="x">
		</span><span class="n">prodValue</span><span class="p">,</span><span class="x"> </span><span class="n">proSumValue</span><span class="x"> </span><span class="kt">int</span><span class="x">
		</span><span class="n">err</span><span class="x">                    </span><span class="kt">error</span><span class="x">
	</span><span class="p">)</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="m">3</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
	  </span><span class="c">// Implements the select as an object containing the select cases built above.</span><span class="x">
		</span><span class="n">chosen</span><span class="p">,</span><span class="x"> </span><span class="n">recv</span><span class="p">,</span><span class="x"> </span><span class="n">_</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">Select</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">SelectCase</span><span class="p">{</span><span class="n">prod</span><span class="p">,</span><span class="x"> </span><span class="n">prodsum</span><span class="p">,</span><span class="x"> </span><span class="n">errSel</span><span class="p">})</span><span class="x">
		</span><span class="n">value</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">recv</span><span class="o">.</span><span class="n">Interface</span><span class="p">()</span><span class="x">
		</span><span class="k">switch</span><span class="x"> </span><span class="n">chosen</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="k">case</span><span class="x"> </span><span class="m">0</span><span class="o">:</span><span class="x">
			</span><span class="n">prodValue</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">value</span><span class="o">.</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="x">
		</span><span class="k">case</span><span class="x"> </span><span class="m">1</span><span class="o">:</span><span class="x">
			</span><span class="n">proSumValue</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">value</span><span class="o">.</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="x">
		</span><span class="k">case</span><span class="x"> </span><span class="m">2</span><span class="o">:</span><span class="x">
			</span><span class="k">if</span><span class="x"> </span><span class="n">value</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
				</span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">value</span><span class="o">.</span><span class="p">(</span><span class="kt">error</span><span class="p">)</span><span class="x">
			</span><span class="p">}</span><span class="x">
		</span><span class="p">}</span><span class="x">

	</span><span class="p">}</span><span class="x">
	</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">prodValue</span><span class="p">,</span><span class="x"> </span><span class="n">proSumValue</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="p">)</span><span class="x">

</span><span class="p">}</span></code></pre></figure>

<p>Not bad, the target function is encapsulated and every of its returned value is now transferred to a channel.
But wait a minute, the code is really cumbersome and verbose,
Maybe it could be more effective and readable if I could pass my own channels.</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="c">// main</span><span class="x">
</span><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="p">(</span><span class="x">
	</span><span class="s">"fmt"</span><span class="x">
	</span><span class="s">"log"</span><span class="x">
	</span><span class="s">"reflect"</span><span class="x">
</span><span class="p">)</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="x"> </span><span class="n">b</span><span class="p">,</span><span class="x"> </span><span class="n">q</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="n">b</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="n">q</span><span class="p">,</span><span class="x"> </span><span class="n">a</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="n">b</span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="x"> </span><span class="no">nil</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="c">// Now I pass a variadic arg of chans of reflect.Value.</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="n">make_function_chan</span><span class="p">(</span><span class="n">f</span><span class="x"> </span><span class="k">interface</span><span class="p">{},</span><span class="x"> </span><span class="n">chans</span><span class="x"> </span><span class="o">...</span><span class="k">chan</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">v</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="x">
	</span><span class="n">t</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">TypeOf</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="x">
	</span><span class="n">fn</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">args</span><span class="x"> </span><span class="p">[]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span><span class="x"> </span><span class="p">[]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="x"> </span><span class="p">{</span><span class="x">

		</span><span class="n">values</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">v</span><span class="o">.</span><span class="n">Call</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="x">
		</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">value</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">values</span><span class="x"> </span><span class="p">{</span><span class="x">

			</span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">k</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">val</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
				</span><span class="n">c</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">chans</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="x">
				</span><span class="c">// Channel transmitted ? Ok, otherwise skip it.</span><span class="x">
				</span><span class="k">if</span><span class="x"> </span><span class="n">c</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
					</span><span class="n">c</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="n">val</span><span class="x">
				</span><span class="p">}</span><span class="x">

			</span><span class="p">}(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">value</span><span class="p">)</span><span class="x">
		</span><span class="p">}</span><span class="x">
		</span><span class="c">// The encapsulating function is now of type 'void' as all values will be transmitted by channels.</span><span class="x">
		</span><span class="k">return</span><span class="x"> </span><span class="p">[]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">{}</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="n">ins</span><span class="p">,</span><span class="x"> </span><span class="n">outs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Type</span><span class="p">,</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">NumIn</span><span class="p">()),</span><span class="x"> </span><span class="p">[]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Type</span><span class="p">{}</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">NumIn</span><span class="p">();</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">ins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">In</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">MakeFunc</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">FuncOf</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span><span class="x"> </span><span class="n">outs</span><span class="p">,</span><span class="x"> </span><span class="no">false</span><span class="p">),</span><span class="x"> </span><span class="n">fn</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">r1</span><span class="p">,</span><span class="x"> </span><span class="n">r2</span><span class="p">,</span><span class="x"> </span><span class="n">errorChan</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">),</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">),</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span><span class="x">
	</span><span class="n">newF</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">make_function_chan</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="x"> </span><span class="n">r1</span><span class="p">,</span><span class="x"> </span><span class="n">r2</span><span class="p">,</span><span class="x"> </span><span class="n">errorChan</span><span class="p">)</span><span class="x">
	</span><span class="n">newF</span><span class="o">.</span><span class="n">Call</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">{</span><span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="m">10</span><span class="p">),</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="m">34</span><span class="p">),</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="m">5</span><span class="p">)})</span><span class="x">
	</span><span class="c">// Thanks to using plain old channels, I can write plain old select statement.</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="m">3</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="k">select</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="k">case</span><span class="x"> </span><span class="n">a</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">r1</span><span class="o">:</span><span class="x">
			</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Interface</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span><span class="x">
		</span><span class="k">case</span><span class="x"> </span><span class="n">b</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">r2</span><span class="o">:</span><span class="x">
			</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">Interface</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span><span class="x">
		</span><span class="k">case</span><span class="x"> </span><span class="n">errValue</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">errorChan</span><span class="o">:</span><span class="x">
			</span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">errValue</span><span class="o">.</span><span class="n">Interface</span><span class="p">()</span><span class="x">
			</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
				</span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="p">(</span><span class="kt">error</span><span class="p">))</span><span class="x">
			</span><span class="p">}</span><span class="x">
		</span><span class="p">}</span><span class="x">
	</span><span class="p">}</span><span class="x">
</span><span class="p">}</span></code></pre></figure>

<p>Much better ! But still I’m forced to provide as many channels as returned values. But what if I’m not concerned with every value ? 
I should be able to distinguish between directly returned values and ‘channeled’ returned values. 
In addition, calling the function is still very odd and involves reflection API. Select statement is still cribbled with reflection API as well.
Can we clean the code to make all the reflection plumbing transparent?</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="c">// main</span><span class="x">
</span><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="p">(</span><span class="x">
	</span><span class="s">"fmt"</span><span class="x">
	</span><span class="s">"reflect"</span><span class="x">
</span><span class="p">)</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="x"> </span><span class="n">b</span><span class="p">,</span><span class="x"> </span><span class="n">q</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="n">b</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="n">q</span><span class="p">,</span><span class="x"> </span><span class="n">a</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="n">b</span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="x"> </span><span class="no">nil</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">WrapFunc</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">args</span><span class="x"> </span><span class="o">...</span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">[]</span><span class="k">interface</span><span class="p">{}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">make_function_mix_wrap</span><span class="p">(</span><span class="n">f</span><span class="x"> </span><span class="k">interface</span><span class="p">{},</span><span class="x"> </span><span class="n">chans</span><span class="x"> </span><span class="o">...</span><span class="k">chan</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="n">WrapFunc</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">v</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="x">
	</span><span class="n">t</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">TypeOf</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="x">
	</span><span class="c">// outs will be set later.</span><span class="x">
	</span><span class="n">ins</span><span class="p">,</span><span class="x"> </span><span class="n">outs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Type</span><span class="p">,</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">NumIn</span><span class="p">()),</span><span class="x"> </span><span class="p">[]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Type</span><span class="p">{}</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">NumIn</span><span class="p">();</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">ins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">In</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">

	</span><span class="k">var</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="x">
</span><span class="c">/*
Now I'm only retaining value type of returned values if no channel was provided for the corresponding returned value.	
 I must keep the matching of returned values from the orginal function and returned values from encapsulating function.
*/</span><span class="x">
	</span><span class="n">outMatchings</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">ch</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">chans</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="k">if</span><span class="x"> </span><span class="n">ch</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="c">// I keep only returned values types for returned values without corresponding channel.</span><span class="x">
			</span><span class="n">outs</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">Out</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="x">
			</span><span class="n">outMatchings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">j</span><span class="x">
			</span><span class="n">j</span><span class="o">++</span><span class="x">
		</span><span class="p">}</span><span class="x">

	</span><span class="p">}</span><span class="x">

	</span><span class="n">fn</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">args</span><span class="x"> </span><span class="p">[]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span><span class="x"> </span><span class="p">[]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="x"> </span><span class="p">{</span><span class="x">

		</span><span class="n">results</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="p">)</span><span class="x">
		</span><span class="n">values</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">v</span><span class="o">.</span><span class="n">Call</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="x">
		</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">value</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">values</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="n">c</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">chans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x">
			</span><span class="c">// If no channel for this returned value, I add the result to the returned values of encapsulating function.</span><span class="x">
			</span><span class="c">// I need there the matching as stated above.</span><span class="x">
			</span><span class="k">if</span><span class="x"> </span><span class="n">c</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
				</span><span class="n">results</span><span class="p">[</span><span class="n">outMatchings</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">value</span><span class="x">
			</span><span class="p">}</span><span class="x"> </span><span class="k">else</span><span class="x"> </span><span class="p">{</span><span class="x">
				</span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">valueChan</span><span class="x"> </span><span class="k">chan</span><span class="x"> </span><span class="k">interface</span><span class="p">{},</span><span class="x"> </span><span class="n">val</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
					</span><span class="n">valueChan</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="n">val</span><span class="o">.</span><span class="n">Interface</span><span class="p">()</span><span class="x">
				</span><span class="p">}(</span><span class="n">c</span><span class="p">,</span><span class="x"> </span><span class="n">value</span><span class="p">)</span><span class="x">
			</span><span class="p">}</span><span class="x">
		</span><span class="p">}</span><span class="x">
		</span><span class="k">return</span><span class="x"> </span><span class="n">results</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="c">// Now the first encapsulating function ...</span><span class="x">
	</span><span class="n">newF</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">MakeFunc</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">FuncOf</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span><span class="x"> </span><span class="n">outs</span><span class="p">,</span><span class="x"> </span><span class="no">false</span><span class="p">),</span><span class="x"> </span><span class="n">fn</span><span class="p">)</span><span class="x">
	</span><span class="c">// ... is itself encapsulated for the sake of consistency with casual function calls.</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">args</span><span class="x"> </span><span class="o">...</span><span class="k">interface</span><span class="p">{})</span><span class="x"> </span><span class="p">[]</span><span class="k">interface</span><span class="p">{}</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">newArgs</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">([]</span><span class="n">reflect</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span><span class="x">
		</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">v</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">args</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="n">newArgs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="x">
		</span><span class="p">}</span><span class="x">
		</span><span class="n">encapsulatingValues</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">newF</span><span class="o">.</span><span class="n">Call</span><span class="p">(</span><span class="n">newArgs</span><span class="p">)</span><span class="x">
		</span><span class="n">returnedValues</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">([]</span><span class="k">interface</span><span class="p">{},</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">encapsulatingValues</span><span class="p">))</span><span class="x">
		</span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">v</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">encapsulatingValues</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="n">returnedValues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">v</span><span class="o">.</span><span class="n">Interface</span><span class="p">()</span><span class="x">
		</span><span class="p">}</span><span class="x">
		</span><span class="k">return</span><span class="x"> </span><span class="n">returnedValues</span><span class="x">

	</span><span class="p">}</span><span class="x">

</span><span class="p">}</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="n">prodChan</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="k">interface</span><span class="p">{})</span><span class="x">
	</span><span class="n">newF</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">make_function_mix_wrap</span><span class="p">(</span><span class="n">add</span><span class="p">,</span><span class="x"> </span><span class="n">prodChan</span><span class="p">,</span><span class="x"> </span><span class="no">nil</span><span class="p">,</span><span class="x"> </span><span class="no">nil</span><span class="p">)</span><span class="x">
	</span><span class="n">values</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">newF</span><span class="p">(</span><span class="m">10</span><span class="p">,</span><span class="x"> </span><span class="m">34</span><span class="p">,</span><span class="x"> </span><span class="m">5</span><span class="p">)</span><span class="x">
	</span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">value</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">values</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="x">
	</span><span class="p">}</span><span class="x">
	</span><span class="n">prod</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">prodChan</span><span class="x">
	</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"prod"</span><span class="p">,</span><span class="x"> </span><span class="n">prod</span><span class="p">)</span><span class="x">
</span><span class="p">}</span></code></pre></figure>

<p>Finally, something usable even if it lacks lot of guards.It could even be changed to return new channels with results instead of getting one from the caller.
I leave it to the reader as a useful exercice.
This little experience shows clealy that reflection in Golang can be really powerful. 
It’s really underestimated but to my eyes it should gain in easiness. Encapsulating and transforming a function also known as Decorator is heavy to implement.
Compare it to Python,Javascript or even to languages like Erlang/Elixir with their very versatile macros !
Nevertheless, it can make your code more usable and readable and reflection API opens new ways to improve your code. 
And now you’re expert in a very advanced language feature !</p>


<div class="post-footer">
  
</div>
<hr/>


  
    <div class="post-navs row">
      
        <div class="col-md-6 post-nav">

          <h3 class="section-header">
            Older
            <span class="text-muted"> &middot; </span>
            <a href="/archive">View Archive (3)</a>
          </h3>

          <h2 class="post-title-link"><a href="/posts/seneca-docker">Microservices with Seneca and Docker</a></h2>
          <p>Microservices are the new trend in composing applications with small and reusable pieces of logic accessible from any clients.But if services should be light and tiny as possible, what about their execution environment ? Can I expect to run hundreds of microservices each with their own and heavy application server ? If so, application server would demand much more resources than our little service, the ratio would be catastrophic. Is there a solution to run microservices on micro application servers and why not on micro os ? Yes, the solution is Seneca plus Docker.</p>


        </div>
      
      
    </div>
  



          <footer>
<hr/>
  <div class="left">  
    &copy;2019.
    Built with <a href="http://jekyllrb.com/">Jekyll</a> and
    <a href="https://github.com/railsr/autm-rb">Autm-rb</a>
  </div>

  <div class="right">
    
      <a href=""><i class="fa fa-twitter fa-lg" style="color:#49B1F7;"></i></a>
    </a>
    
  </div>
</footer>

        </section>
    </div>
    </div>
    <script src="/public/javascripts/jquery.min.js"></script>
    <script src="/public/javascripts/bootstrap.min.js"></script>
    <script src="http://cdn.jsdelivr.net/velocity/1.2.2/velocity.min.js"></script>
    <script src="/public/javascripts/enhance.js"></script>
   
    <!-- Place your <script> tags here. -->

<!-- disqus comment counter -->
<script type="text/javascript">
	/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'test';

	/* * * DON'T EDIT BELOW THIS LINE * * */
	(function () {
	    var s = document.createElement('script'); s.async = true;
	    s.type = 'text/javascript';
	    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
	    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
	}());
</script>
<!-- /disqus comment counter -->
		
		
		
<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', '', 'auto');
  ga('send', 'pageview');

</script>
<!-- /google analytics -->

  </body>
</html>
